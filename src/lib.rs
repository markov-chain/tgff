//! The package provides a parser for the
//! [TGFF](http://ziyang.eecs.umich.edu/~dickrp/tgff/) (Task Graphs For Free)
//! format, which is a format for storing task graphs and accompanying data
//! used in scheduling and allocation research.

#![feature(macro_rules, if_let)]

use std::collections::HashMap;
use std::iter::Peekable;
use std::str::CharOffsets;

pub use content::Content;
pub use content::{Graph, Task, Arc, Deadline};
pub use content::{Table, Column};

mod content;

static READ_CAPACITY: uint = 20;

pub type Result<T> = std::result::Result<T, Error>;

pub struct Error {
    line: uint,
    message: &'static str,
}

impl std::fmt::Show for Error {
    fn fmt(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(formatter, "{} on line {}", self.message, self.line)
    }
}

pub struct Parser<'a> {
    line: uint,
    cursor: Peekable<(uint, char), CharOffsets<'a>>,
    content: Content,
}

macro_rules! raise(
    ($parser:expr, $message:expr) => (
        return Err(Error { line: $parser.line, message: $message });
    );
)

macro_rules! some(
    ($parser:expr, $result:expr, $message:expr) => (
        match $result {
            Some(result) => result,
            None => raise!($parser, $message),
        }
    );
)

impl<'a> Parser<'a> {
    /// Create a new `Parser` for processing the content of a TGFF file
    /// generated by the `tgff` command-line utility and given in `input`.
    pub fn new(input: &'a str) -> Parser<'a> {
        Parser {
            line: 1,
            cursor: input.char_indices().peekable(),
            content: Content::new(),
        }
    }

    /// Perform parsing of the data passed to `new`.
    pub fn process<'a>(&'a mut self) -> Result<&'a Content> {
        loop {
            match self.peek() {
                Some('@') => try!(self.process_at()),
                Some(_) => raise!(self, "found an unknown statement"),
                None => return Ok(&self.content),
            }
        }
    }

    fn process_at(&mut self) -> Result<()> {
        self.next(); // @

        let name = some!(self, self.read_token(),
                         "found an @-statement without a name");
        let number = some!(self, self.read_natural(),
                           "found an @-statement not followed by a natural number");

        if let Some('{') = self.peek() {
            self.process_block(name, number)
        } else {
            self.content.set_attribute(name, number);
            Ok(())
        }
    }

    fn process_block(&mut self, name: String, id: uint) -> Result<()> {
        self.next(); // {
        self.skip_void();

        if let Some('#') = self.peek() {
            let mut table = Table::new(name, id);
            try!(self.process_table(&mut table));
        } else {
            let mut graph = Graph::new(name, id);
            try!(self.process_graph(&mut graph));
        }

        if let Some('}') = self.peek() {
            self.next();
            return Ok(());
        }

        raise!(self, "cannot find the end of a {}-block");
    }

    fn process_graph(&mut self, graph: &mut Graph) -> Result<()> {
        loop {
            match self.read_token() {
                Some(ref token) => match token.as_slice() {
                    "TASK" => {
                        let id = some!(self, self.read_id(),
                                       "found a task without an id");

                        some!(self, self.read_str("TYPE"),
                              "found a task without a type");

                        let kind = some!(self, self.read_natural(),
                                         "found a task without a type");

                        graph.add_task(id, kind);
                    },
                    "ARC" => {
                    },
                    "HARD_DEADLINE" => {
                    },
                    _ => {
                        let value = some!(self, self.read_natural(),
                                          "found an attribute not followed by a natural number");

                        graph.set_attribute(token.clone(), value);
                    },
                },
                None => break,
            }
        }

        Ok(())
    }

    fn process_table(&mut self, table: &mut Table) -> Result<()> {
        Ok(())
    }

    fn skip(&mut self, accept: |uint, char| -> bool) -> uint {
        let mut count = 0;

        loop {
            match self.peek() {
                Some(c) => {
                    if !accept(count, c) { break; }
                    self.next();
                    count += 1;
                },
                None => break,
            }
        }

        count
    }

    #[inline]
    fn skip_void(&mut self) {
        self.skip(|_, c| c == ' ' || c == '\t' || c == '\n');
    }

    fn read(&mut self, accept: |uint, char| -> bool) -> Option<String> {
        let mut result = std::string::String::with_capacity(READ_CAPACITY);
        let mut count = 0;

        loop {
            match self.peek() {
                Some(c) => {
                    if !accept(count, c) { break; }
                    result.push(c);
                    self.next();
                    count += 1;
                },
                None => break,
            }
        }

        if count == 0 {
            None
        } else {
            Some(result)
        }
    }

    fn read_token(&mut self) -> Option<String> {
        let result = self.read(|i, c| {
            match c {
                'A'...'Z' | 'a'...'z' if i == 0 => true,
                'A'...'Z' | 'a'...'z' | '_' | '0'...'9' if i > 0 => true,
                _ => false,
            }
        });
        self.skip_void();
        result
    }

    fn read_natural(&mut self) -> Option<uint> {
        let result = match self.read(|_, c| c >= '0' && c <= '9') {
            Some(ref number) => std::num::from_str_radix(number.as_slice(), 10),
            None => None,
        };
        self.skip_void();
        result
    }

    fn read_str(&mut self, expected: &str) -> Option<String> {
        let len = expected.len();
        let result = match self.read(|i, c| i < len && c == expected.char_at(i)) {
            Some(found) => if found.len() == len { Some(found) } else { None },
            None => None,
        };
        self.skip_void();
        result
    }

    fn read_id(&mut self) -> Option<uint> {
        match self.read_token() {
            Some(ref token) => match token.as_slice().split('_').nth(1) {
                Some(id) => std::num::from_str_radix(id, 10),
                None => None,
            },
            None => None,
        }
    }

    #[inline]
    fn peek(&mut self) -> Option<char> {
        match self.cursor.peek() {
            Some(&(_, c)) => Some(c),
            None => None,
        }
    }
}

impl<'a> std::iter::Iterator<char> for Parser<'a> {
    fn next(&mut self) -> Option<char> {
        match self.cursor.next() {
            Some((_, '\n')) => {
                self.line += 1;
                Some('\n')
            },
            Some((_, c)) => Some(c),
            None => None,
        }
    }
}

#[cfg(test)]
mod tests {
    macro_rules! assert_ok(
        ($result: expr) => (
            if let Err(err) = $result {
                assert!(false, "{}", err);
            }
        );
    )

    macro_rules! assert_error(
        ($result: expr) => (
            if let Ok(_) = $result {
                assert!(false, "expected an error");
            }
        );
    )

    macro_rules! parser(
        ($input:expr) => (super::Parser::new($input));
    )

    macro_rules! graph(
        ($name:expr, $id:expr) => (
            super::Graph::new(String::from_str($name), $id)
        );
    )

    #[test]
    fn process_at() {
        assert_ok!(parser!("@abc 12").process_at());
        assert_error!(parser!("@ ").process_at());
        assert_error!(parser!("@abc").process_at());
    }

    #[test]
    fn process_block() {
        assert_ok!(parser!("{}").process_block(String::from_str("life"), 42));
    }

    #[test]
    fn process_graph() {
        let mut graph = graph!("life", 42);

        assert_ok!(parser!("TASK t0_0\tTYPE 2   ").process_graph(&mut graph));

        assert!(graph.tasks.len() == 1);
        assert!(graph.tasks[0].id == 0);
        assert!(graph.tasks[0].kind == 2);
    }

    #[test]
    fn process_table() {
    }

    #[test]
    fn skip_void() {
        let mut parser = parser!("  \t  abc");
        parser.skip_void();
        assert_eq!(parser.next().unwrap(), 'a');
    }

    #[test]
    fn read_token() {
        macro_rules! test(
            ($input:expr, $output:expr) => (
                assert_eq!(parser!($input).read_token().unwrap(),
                           String::from_str($output));
            );
        )

        test!("AZ xyz", "AZ");
        test!("az xyz", "az");
        test!("AZ_az_09 xyz", "AZ_az_09");
    }

    #[test]
    fn read_natural() {
        assert_eq!(parser!("09").read_natural().unwrap(), 9);
    }

    #[test]
    fn read_id() {
        assert_eq!(parser!("t0_42").read_id().unwrap(), 42);
    }
}
